<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>接近感覚テストゲーム (CSS分離版)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div id="game-container">
        
        <div id="world">
            <div id="ground"></div>
            <div id="road">
                <div id="center-line"></div>
            </div>
        </div>

        <div id="cube-container">
            <div class="face front" id="cube-front"></div>
            <div class="face back"></div>
            <div class="face left"></div>
            <div class="face right"></div>
            <div class="face top"></div>
            <div class="face bottom"></div>
        </div>

        <div id="collision-line"></div> 
        <div id="info-display">第1問</div>

        <div id="start-screen">
            <h1>接近感覚テスト (バグ修正版)</h1>
            <p id="instructions">物体が迫ってきます。<br>限界だと思った瞬間に [スペースキー] を押してください。<br><br>画面の最も手前にある<span style="color: rgba(255, 0, 0, 0.6); text-shadow: none;">赤い半透明の壁</span>が衝突ラインです。</p>
            <button id="start-button">スタート</button>
        </div>
    </div>

    <script>
        // --- 1. 定数・変数の設定 ---
        const cubeContainer = document.getElementById('cube-container');
        const cubeFront = document.getElementById('cube-front');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const infoDisplay = document.getElementById('info-display');

        const BASE_COLOR = '#808080';
        const NO_SOUND = null;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#00FFFF', '#FF00FF', '#FFFF00'];
        const soundNames = ['White Noise', 'Pink Noise', 'Brown Noise'];

        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffers = {};
        let currentSoundSource = null;
        let gainNode = null; 

        const CUBE_SIZE_HALF = 50;
        const START_Z_OFFSET = -3000;
        const END_Z_OFFSET = 0;
        const SPEED = 10;
        const TOTAL_QUESTIONS = 10;
        const METER_CONVERSION_RATIO = 10;

        let animationFrameId = null;
        let currentTrialSettings = [];
        let currentQuestionIndex = 0;
        let results = [];
        let gameRunning = false;
        let currentCubeZ = 0;

        // --- 2. 音声の生成 ---
        const bufferDuration = 2;
        function createWhiteNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < frameCount; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }
        function createBrownNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0.0;
            for (let i = 0; i < frameCount; i++) {
                const white = Math.random() * 2 - 1;
                let out = (lastOut + (0.02 * white));
                if (out > 1.0) out = 1.0; if (out < -1.0) out = -1.0;
                data[i] = out; lastOut = out;
            }
            return buffer;
        }
        function createPinkNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < frameCount; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980;
                let pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; b6 = white * 0.115926;
                data[i] = pink * 0.11;
            }
            let max = 0;
            for(let i=0; i<frameCount; i++) if(Math.abs(data[i]) > max) max = Math.abs(data[i]);
            if(max > 1.0) for(let i=0; i<frameCount; i++) data[i] /= max;
            return buffer;
        }
        function generateSounds() {
            try {
                audioBuffers[soundNames[0]] = createWhiteNoise();
                audioBuffers[soundNames[1]] = createPinkNoise();
                audioBuffers[soundNames[2]] = createBrownNoise();
                console.log("音声の準備完了。");
            } catch (error) {
                console.error("音声の生成に失敗しました:", error);
            }
        }

        // --- 3. 問題の準備 ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        function createTrialSet() {
            currentTrialSettings = [];
            currentTrialSettings.push({ 
                color: BASE_COLOR, 
                sound: NO_SOUND, 
                type: '基準' 
            });
            let colorTrials = colors.map(c => ({
                color: c,
                sound: NO_SOUND,
                type: '色'
            }));
            let soundTrials = soundNames.map(s => ({
                color: BASE_COLOR,
                sound: s,
                type: '音'
            }));
            let remainingTrials = [...colorTrials, ...soundTrials];
            shuffleArray(remainingTrials);
            currentTrialSettings = [...currentTrialSettings, ...remainingTrials];
        }

        // --- 4. 音声制御 ---
        function playSound(soundName) {
            if (currentSoundSource) {
                currentSoundSource.stop();
            }
            if (soundName === NO_SOUND) {
                gainNode = null;
                return;
            }
            const buffer = audioBuffers[soundName];
            if (!buffer) return;
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            currentSoundSource = audioContext.createBufferSource();
            currentSoundSource.buffer = buffer;
            gainNode = audioContext.createGain();
            currentSoundSource.connect(gainNode);
            gainNode.connect(audioContext.destination);
            currentSoundSource.loop = true;
            const randomStartTime = Math.random() * bufferDuration;
            currentSoundSource.start(0, randomStartTime);
        }
        function updateVolume(z) {
            if (!gainNode) return;
            let volume = 1.0 - (z / START_Z_OFFSET);
            volume = Math.max(0, Math.min(1, volume));
            gainNode.gain.value = volume;
        }

        // --- 5. ゲームロジック ---
        startButton.addEventListener('click', () => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (Object.keys(audioBuffers).length < soundNames.length) {
                alert("まだ音声データを生成しています。"); return;
            }
            startGame();
        });
        function startGame() {
            startScreen.style.display = 'none';
            gameRunning = true;
            currentQuestionIndex = 0;
            results = [];
            createTrialSet();
            runNextTrial();
        }
        function runNextTrial() {
            if (currentQuestionIndex >= TOTAL_QUESTIONS) {
                finishGame();
                return;
            }
            const trial = currentTrialSettings[currentQuestionIndex];
            currentCubeZ = START_Z_OFFSET; 
            updateCubePosition(currentCubeZ);
            cubeFront.style.backgroundColor = trial.color;
            playSound(trial.sound);
            updateVolume(currentCubeZ);
            infoDisplay.innerText = `第 ${currentQuestionIndex + 1} 問`;
            infoDisplay.style.color = 'white';
            gameRunning = true;
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function updateCubePosition(z) {
            const scale = 0.1 + (0.9 * (1.0 - (z / START_Z_OFFSET)));
            cubeContainer.style.setProperty('--z', `${z}px`);
            cubeContainer.style.setProperty('--scale', scale);
        }
        function gameLoop() {
            if (!gameRunning) return;
            currentCubeZ += SPEED;
            updateCubePosition(currentCubeZ);
            updateVolume(currentCubeZ);
            if (currentCubeZ + CUBE_SIZE_HALF >= END_Z_OFFSET) {
                handleCollision();
            } else {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // --- 6. ユーザー入力とフィードバック (バグ修正済み) ---
        document.addEventListener('keydown', (event) => {
            if (gameRunning && event.code === 'Space') {
                event.preventDefault(); 
                gameRunning = false;
                
                cancelAnimationFrame(animationFrameId);
                if (currentSoundSource) {
                    currentSoundSource.stop();
                }

                // 衝突ライン(0) と キューブの前面 (負の値) との距離を計算
                const remainingDistance = Math.max(0, END_Z_OFFSET - (currentCubeZ + CUBE_SIZE_HALF));
                const scoreMeters = remainingDistance / METER_CONVERSION_RATIO;

                infoDisplay.innerText = `結果: 残り ${scoreMeters.toFixed(1)} m`;
                infoDisplay.style.color = '#00FF00';

                recordResult(scoreMeters, false);

                currentQuestionIndex++;
                setTimeout(runNextTrial, 2000);
            }
        });

        // --- 7. 衝突・終了処理 ---
        function handleCollision() {
            gameRunning = false;
            if (currentSoundSource) {
                currentSoundSource.stop();
            }
            infoDisplay.innerText = `衝突 (残り 0.0 m)`;
            infoDisplay.style.color = '#FF0000';
            recordResult(0, true);
            currentQuestionIndex++;
            setTimeout(runNextTrial, 2000);
        }
        function recordResult(scoreMeters, collided) {
            const trial = currentTrialSettings[currentQuestionIndex];
            const resultData = {
                question: currentQuestionIndex + 1,
                type: trial.type,
                color: trial.color,
                sound: trial.sound,
                scoreMeters: scoreMeters,
                collided: collided
            };
            results.push(resultData);
            console.log(`【記録 ${resultData.question}】`, resultData);
        }
        function finishGame() {
            gameRunning = false;
            startScreen.style.display = 'flex';
            document.getElementById('instructions').innerHTML = 'テスト終了。お疲れ様でした。<br>（結果はコンソールを確認してください）<br><br>画面の最も手前にある<span style="color: rgba(255, 0, 0, 0.6); text-shadow: none;">赤い半透明の壁</span>が衝突ラインです。';
            startButton.innerText = 'もう一度行う';
            console.log("--- 全試行結果 ---");
            console.table(results);
        }

        generateSounds();
    </script>
</body>
</html>