<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>接近感覚テストゲーム (Canvas 3D版 - 改良版)</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <div id="game-wrapper">
        <canvas id="game-canvas" width="800" height="600"></canvas>
        
        <div id="info-display" class="hidden">第1問</div>
        <div id="game-message" class="hidden">ぎりぎりで避けよう！</div> 
        <div id="results-log" class="hidden"></div> 
        <button id="dodge-button" class="hidden">回避</button> 
        
        <div id="start-screen">
            <h1>接近感覚テスト (Canvas 3D版)</h1>
            
            <div id="user-info-form">
                <div class="form-group">
                    <label for="age-select">年代:</label>
                    <select id="age-select">
                        <option value="">選択してください</option>
                        <option value="10s">10代</option>
                        <option value="20s">20代</option>
                        <option value="30s">30代</option>
                        <option value="40s">40代</option>
                        <option value="50s">50代</option>
                        <option value="60s+">60代以上</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="gender-select">性別:</label>
                    <select id="gender-select">
                        <option value="">選択してください</option>
                        <option value="male">男性</option>
                        <option value="female">女性</option>
                        <option value="other">その他</option>
                        <option value="prefer_not_to_say">回答しない</option>
                    </select>
                </div>
                <p id="form-error-message" class="hidden">年代と性別を選択してください。</p>
            </div>

            <div id="instructions">
                <p>
                    物体が迫ってきます。<br>
                    下のハンドルにぶつかると思った瞬間に<br>
                    [スペースキー] または [回避ボタン] を押してください。
                </p>
            </div>

            <div id="feedback-form" class="hidden">
                <div class="form-group">
                    <label for="feedback-text">ご協力ありがとうございました。よろしければご意見・ご感想をお聞かせください：</label>
                    <textarea id="feedback-text" rows="3" placeholder="（例：赤色の時が一番速く感じた、など）"></textarea>
                </div>
            </div>
            
            <button id="start-button">スタート</button>
        </div>
    </div>

    <script>
        // --- 1. 定数・変数の設定 (★修正あり) ---
        
        // ★★★★★ 重要 ★★★★★
        // GASを「新しいデプロイ」した後に発行される【新しいURL】に必ず書き換えてください
        const GAS_URL = 'https://script.google.com/macros/s/AKfycbzn08w-nj5gLoxniFgUReRpv8EUlQ7ugbF8gcs1bZO8QSolhCu274D1oye1JUceK8o6GA/exec'; 

        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('start-screen');
        const startButton = document.getElementById('start-button');
        const infoDisplay = document.getElementById('info-display');
        const gameMessage = document.getElementById('game-message'); 
        const instructionsDiv = document.getElementById('instructions');
        const dodgeButton = document.getElementById('dodge-button'); 
        const resultsLog = document.getElementById('results-log'); 
        const userInfoForm = document.getElementById('user-info-form');
        const ageSelect = document.getElementById('age-select');
        const genderSelect = document.getElementById('gender-select');
        const formErrorMessage = document.getElementById('form-error-message');
        const feedbackForm = document.getElementById('feedback-form');
        const feedbackText = document.getElementById('feedback-text');

        const WIDTH = canvas.width;
        const HEIGHT = canvas.height;
        const CAMERA_Z = -100;
        const FIELD_OF_VIEW = 500;
        const HORIZON_OFFSET = 50; 

        // ★(変更) 基準試行(QQ)用のグレーを追加
        const GREY_COLOR = '#808080'; // QQ (グレー)
        const BASE_COLOR = '#FFFFFF'; // 音響試行用のベース色 (白)
        const NO_SOUND = null;
        const colors = ['#FF0000', '#00FF00', '#0000FF', '#00FFFF', '#FF00FF', '#FFFF00'];
        const soundNames = ['White Noise', 'Pink Noise', 'Brown Noise'];
        const ENGINE_SOUND_NAME = 'Engine Sound'; 
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let audioBuffers = {};
        let currentSoundSource = null;
        let gainNode = null; 

        const CUBE_SIZE = 100;
        const CUBE_HALF = CUBE_SIZE / 2;
        const START_Z = 3000;
        const END_Z = 0;
        const CUBE_SPEED = 15; 
        const LINE_SPEED = 3; 
        const DODGE_SPEED = 30; 
        const DODGE_MAX_OFFSET = 300; 
        const TOTAL_QUESTIONS = 10;
        const METER_CONVERSION_RATIO = 10;

        let animationFrameId = null;
        let currentTrialSettings = [];
        let currentQuestionIndex = 0;
        let results = [];
        let gameRunning = false;
        let currentCubeZ = START_Z;
        let dodgeOffset = 0;
        let isDodging = false;
        let isWaitingToReturn = false;
        let isReturning = false;
        let centerLineOffset = 0;
        let isCollided = false;
        let collisionTimer = 0;
        const COLLISION_ANIMATION_DURATION = 60; 
        let isWaitingToStart = false;
        let startDelayTimer = 0; 
        
        let userAge = '';
        let userGender = '';
        let gameStartTime = null;
        let gameElapsedTime = 0;

        // --- 2. 音声の生成 (変更なし) ---
        const bufferDuration = 2;
        function createEngineSound() {
            try {
                const frameCount = audioContext.sampleRate * bufferDuration;
                const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                const freq = 80; 
                const sampleRate = audioContext.sampleRate;
                let lastVal = 0;
                for (let i = 0; i < frameCount; i++) {
                    let t = i / sampleRate;
                    let saw = 2 * (t * freq - Math.floor(0.5 + t * freq));
                    let noise = (Math.random() * 2 - 1) * 0.05; 
                    let val = saw + noise;
                    let filteredVal = val * 0.1 + lastVal * 0.9; 
                    lastVal = filteredVal;
                    data[i] = filteredVal * 0.5; 
                }
                return buffer;
            } catch (e) {
                console.error("エンジン音の生成に失敗:", e);
                return null;
            }
        }
        function createWhiteNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < frameCount; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }
        function createBrownNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            let lastOut = 0.0;
            for (let i = 0; i < frameCount; i++) {
                const white = Math.random() * 2 - 1;
                let out = (lastOut + (0.02 * white));
                if (out > 1.0) out = 1.0; if (out < -1.0) out = -1.0;
                data[i] = out; lastOut = out;
            }
            return buffer;
        }
        function createPinkNoise() {
            const frameCount = audioContext.sampleRate * bufferDuration;
            const buffer = audioContext.createBuffer(1, frameCount, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
            for (let i = 0; i < frameCount; i++) {
                const white = Math.random() * 2 - 1;
                b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759;
                b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856;
                b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980;
                let pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362; b6 = white * 0.115926;
                data[i] = pink * 0.11;
            }
            let max = 0;
            for(let i=0; i<frameCount; i++) if(Math.abs(data[i]) > max) max = Math.abs(data[i]);
            if(max > 1.0) for(let i=0; i<frameCount; i++) data[i] /= max;
            return buffer;
        }
        function generateSounds() {
            try {
                audioBuffers[ENGINE_SOUND_NAME] = createEngineSound();
                audioBuffers[soundNames[0]] = createWhiteNoise();
                audioBuffers[soundNames[1]] = createPinkNoise();
                audioBuffers[soundNames[2]] = createBrownNoise();
                console.log("音声の準備完了。");
            } catch (error) {
                console.error("音声の生成に失敗しました:", error);
            }
        }

        // --- 3. 問題の準備 (★修正あり) ---
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        function createTrialSet() {
            // ★(変更) 基準試行(QQ)をグレー(#808080)に変更
            const standardTrial = { 
                color: GREY_COLOR, 
                sound: NO_SOUND, 
                type: '基準' // '基準' (Standard) というタイプ名
            };
            let remainingTrials = [];
            let colorTrials = colors.map(c => ({
                color: c,
                sound: NO_SOUND, 
                type: '色'
            }));
            // ★(変更) 音響試行はベース色(白)を使用
            let soundTrials = soundNames.map(s => ({
                color: BASE_COLOR,
                sound: s,
                type: '音'
            }));
            remainingTrials = [...colorTrials, ...soundTrials];
            shuffleArray(remainingTrials); 
            currentTrialSettings = [standardTrial, ...remainingTrials];
        }

        // --- 4. 音声制御 (変更なし) ---
        function stopCurrentSound(fadeOut = false) { 
            const sourceToStop = currentSoundSource;
            const gainToFade = gainNode;
            currentSoundSource = null;
            gainNode = null;
            
            if (sourceToStop && gainToFade) {
                try {
                    sourceToStop.stop(); 
                } catch (e) {
                    console.warn("Audio stop error (ignorable):", e.message);
                }
            }
        }
        function playSound(soundName) {
            stopCurrentSound(false); 
            
            const soundToPlay = (soundName === NO_SOUND) ? ENGINE_SOUND_NAME : soundName;
            const buffer = audioBuffers[soundToPlay];
            if (!buffer) {
                console.warn(`音声バッファが見つかりません: ${soundToPlay}`);
                return;
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            currentSoundSource = audioContext.createBufferSource();
            currentSoundSource.buffer = buffer;
            gainNode = audioContext.createGain(); 
            currentSoundSource.connect(gainNode);
            gainNode.connect(audioContext.destination);
            currentSoundSource.loop = true;
            const randomStartTime = Math.random() * bufferDuration;
            currentSoundSource.start(0, randomStartTime);
            
            if (isWaitingToStart) {
                gainNode.gain.value = 0;
            } else {
                updateVolume(currentCubeZ);
            }
        }
        function updateVolume(z) {
            if (!gainNode) return;
            let volume = 1.0 - (z / START_Z);
            volume = Math.max(0, Math.min(1, volume));
            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
        }

        // --- 5. 3D描画エンジン (変更なし) ---
        function project(x, y, z) {
            const x_rel = x - dodgeOffset; 
            const y_rel = y;
            const z_rel = z - CAMERA_Z;
            if (z_rel <= 1) return null;
            const scale = FIELD_OF_VIEW / z_rel;
            const screenX = (WIDTH / 2) + (x_rel * scale);
            const screenY = (HEIGHT / 2) + (HORIZON_OFFSET * scale) + (y_rel * scale); 
            return { x: screenX, y: screenY, z: z_rel };
        }
        function drawRoad(lineOffset) {
            const roadY = 0; 
            const roadWidth = 300;
            const laneWidth = 100;
            const zNear = 1; 
            const zFar = 3000; 
            const p1 = project(-roadWidth, roadY, zNear);
            const p2 = project(roadWidth, roadY, zNear);
            const p3 = project(roadWidth, roadY, zFar);
            const p4 = project(-roadWidth, roadY, zFar);
            if (!p1 || !p2 || !p3 || !p4) return;
            ctx.fillStyle = '#555';
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.lineTo(p3.x, p3.y);
            ctx.lineTo(p4.x, p4.y);
            ctx.closePath();
            ctx.fill();
            const l_p1 = project(-laneWidth, roadY, zNear); 
            const l_p2 = project(-laneWidth, roadY, zFar);
            const r_p1 = project(laneWidth, roadY, zNear); 
            const r_p2 = project(laneWidth, roadY, zFar);
            if (!l_p1 || !l_p2 || !r_p1 || !r_p2) return;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 5;
            ctx.setLineDash([20, 30]);
            ctx.lineDashOffset = lineOffset; 
            ctx.beginPath();
            ctx.moveTo(l_p1.x, l_p1.y);
            ctx.lineTo(l_p2.x, l_p2.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(r_p1.x, r_p1.y);
            ctx.lineTo(r_p2.x, r_p2.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        const cubeVertices = [
            [-CUBE_HALF, -CUBE_SIZE, -CUBE_HALF], [ CUBE_HALF, -CUBE_SIZE, -CUBE_HALF], [ CUBE_HALF, 0, -CUBE_HALF], [-CUBE_HALF, 0, -CUBE_HALF], 
            [-CUBE_HALF, -CUBE_SIZE, CUBE_HALF], [ CUBE_HALF, -CUBE_SIZE, CUBE_HALF], [ CUBE_HALF, 0, CUBE_HALF], [-CUBE_HALF, 0, CUBE_HALF]  
        ];
        const cubeFaces = [
            { v: [0, 1, 2, 3], type: 'front' }, { v: [1, 5, 6, 2], type: 'side' },  { v: [5, 4, 7, 6], type: 'back' },  
            { v: [4, 0, 3, 7], type: 'side' },  { v: [4, 5, 1, 0], type: 'top' },  
        ];
        function drawCube(z, baseColor) {
            let projectedVertices = [];
            let facesToDraw = [];
            for (const v of cubeVertices) {
                const projected = project(v[0], v[1], v[2] + z );
                if (projected === null) return; 
                projectedVertices.push(projected);
            }
            const p3 = projectedVertices[3];
            const p2 = projectedVertices[2];
            const p6 = projectedVertices[6];
            const p7 = projectedVertices[7];
            if (p3 && p2 && p6 && p7) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p6.x, p6.y);
                ctx.lineTo(p7.x, p7.y);
                ctx.closePath();
                ctx.fill();
            }
            for (const face of cubeFaces) {
                const p1 = projectedVertices[face.v[0]];
                const p2 = projectedVertices[face.v[1]];
                const p3 = projectedVertices[face.v[2]];
                const p4 = projectedVertices[face.v[3]];
                const avgZ = (p1.z + p2.z + p3.z + p4.z) / 4;
                facesToDraw.push({ type: face.type, points: [p1, p2, p3, p4], depth: avgZ });
            }
            facesToDraw.sort((a, b) => b.depth - a.depth);
            for (const face of facesToDraw) {
                let color;
                if (face.type === 'front') {
                    color = baseColor;
                } else if (face.type === 'side') {
                    let r = parseInt(baseColor.substr(1, 2), 16); let g = parseInt(baseColor.substr(3, 2), 16); let b = parseInt(baseColor.substr(5, 2), 16);
                    color = `rgb(${r * 0.7}, ${g * 0.7}, ${b * 0.7})`;
                } else if (face.type === 'top') {
                    color = 'rgba(255, 255, 255, 0.3)';
                } else {
                    color = 'gray'; 
                }
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.moveTo(face.points[0].x, face.points[0].y);
                ctx.lineTo(face.points[1].x, face.points[1].y);
                ctx.lineTo(face.points[2].x, face.points[2].y);
                ctx.lineTo(face.points[3].x, face.points[3].y);
                ctx.closePath();
                ctx.fill();
            }
        }
        function drawHandlebar() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.beginPath();
            ctx.moveTo(0, HEIGHT);
            ctx.bezierCurveTo(WIDTH * 0.2, HEIGHT - 150, WIDTH * 0.8, HEIGHT - 150, WIDTH, HEIGHT);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#1a1a1a';
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(WIDTH / 2 - 120, HEIGHT - 130, 240, 100, 15);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = '#00BFFF';
            ctx.fillStyle = '#111';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.arc(WIDTH / 2 - 60, HEIGHT - 75, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(WIDTH / 2 + 60, HEIGHT - 75, 40, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#00FF00'; 
            ctx.beginPath();
            ctx.arc(WIDTH / 2 - 100, HEIGHT - 45, 5, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#FF0000'; 
            ctx.beginPath();
            ctx.arc(WIDTH / 2 + 100, HEIGHT - 45, 5, 0, Math.PI*2);
            ctx.fill();
            const gripGrad = ctx.createLinearGradient(0, HEIGHT - 80, 0, HEIGHT - 50);
            gripGrad.addColorStop(0, '#555');
            gripGrad.addColorStop(1, '#111');
            ctx.fillStyle = gripGrad;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.roundRect(50, HEIGHT - 80, 150, 30, 10);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.roundRect(WIDTH - 200, HEIGHT - 80, 150, 30, 10);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(50, HEIGHT - 80);
            ctx.lineTo(100, HEIGHT - 160);
            ctx.stroke();
            const mirrorGradL = ctx.createLinearGradient(70, HEIGHT - 195, 130, HEIGHT - 155);
            mirrorGradL.addColorStop(0, '#5F85AD');
            mirrorGradL.addColorStop(1, '#B0C4DE');
            ctx.fillStyle = mirrorGradL;
            ctx.beginPath();
            ctx.ellipse(100, HEIGHT - 175, 30, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(WIDTH - 50, HEIGHT - 80);
            ctx.lineTo(WIDTH - 100, HEIGHT - 160);
            ctx.stroke();
            const mirrorGradR = ctx.createLinearGradient(WIDTH - 130, HEIGHT - 195, WIDTH - 70, HEIGHT - 155);
            mirrorGradR.addColorStop(0, '#5F85AD');
            mirrorGradR.addColorStop(1, '#B0C4DE');
            ctx.fillStyle = mirrorGradR;
            ctx.beginPath();
            ctx.ellipse(WIDTH - 100, HEIGHT - 175, 30, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
        }
        function draw() {
            ctx.fillStyle = '#5F85AD'; 
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.fillStyle = '#3a3a3a'; 
            ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);
            centerLineOffset = (centerLineOffset + LINE_SPEED) % 50; 
            drawRoad(centerLineOffset);
            const trial = currentTrialSettings[currentQuestionIndex];
            if (!trial) return; 
            drawCube(currentCubeZ, trial.color);
            drawHandlebar();
        }

        // --- 6. gameLoop (変更なし) ---
        function gameLoop() {
            if (!gameRunning) return;

            if (isCollided) {
                collisionTimer--;
                draw(); 
                const shakeIntensity = 20 * (collisionTimer / COLLISION_ANIMATION_DURATION);
                const shakeX = (Math.random() - 0.5) * shakeIntensity;
                const shakeY = (Math.random() - 0.5) * shakeIntensity;
                ctx.save();
                ctx.translate(shakeX, shakeY);
                ctx.fillStyle = '#5F85AD'; 
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                ctx.fillStyle = '#3a3a3a'; 
                ctx.fillRect(0, HEIGHT / 2, WIDTH, HEIGHT / 2);
                drawRoad(centerLineOffset);
                const trial = currentTrialSettings[currentQuestionIndex];
                if(trial) drawCube(END_Z, trial.color); 
                ctx.restore();
                drawHandlebar();
                ctx.fillStyle = `rgba(255, 0, 0, ${Math.max(0, collisionTimer / COLLISION_ANIMATION_DURATION)})`; 
                ctx.fillRect(0, 0, WIDTH, HEIGHT);
                if (collisionTimer <= 0) {
                    isCollided = false;
                    currentCubeZ = START_Z;
                    prepareNextTrial();
                }
                animationFrameId = requestAnimationFrame(gameLoop);
                return; 
            }
            
            if (isDodging) {
                dodgeOffset += DODGE_SPEED;
                if (dodgeOffset >= DODGE_MAX_OFFSET) {
                    dodgeOffset = DODGE_MAX_OFFSET;
                    isDodging = false;
                    isWaitingToReturn = true;
                }
            } else if (isWaitingToReturn) {
                if (currentCubeZ < CAMERA_Z) { 
                    isWaitingToReturn = false;
                    isReturning = true;
                }
            } else if (isReturning) {
                dodgeOffset -= DODGE_SPEED;
                if (dodgeOffset <= 0) {
                    dodgeOffset = 0;
                    isReturning = false;
                    currentCubeZ = START_Z;
                    prepareNextTrial();
                }
            }
            
            if (isWaitingToStart) {
                startDelayTimer--;
                if (startDelayTimer <= 0) {
                    isWaitingToStart = false;
                    updateVolume(currentCubeZ); 
                }
            } else if (!isDodging && !isWaitingToReturn && !isReturning) {
                currentCubeZ -= CUBE_SPEED;
                updateVolume(currentCubeZ);
                gameMessage.textContent = "ぎりぎりで避けよう！";
                gameMessage.style.color = "white";
            } else {
                currentCubeZ -= CUBE_SPEED;
            }
            
            draw(); 
            if (!isWaitingToStart && !isDodging && !isWaitingToReturn && !isReturning) {
                if (currentCubeZ <= END_Z) {
                    handleCollision(); 
                }
            }
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- 7. ユーザー入力とフィードバック (変更なし) ---
        startButton.addEventListener('click', async () => { 
            if (gameRunning === false && results.length > 0) {
                startButton.disabled = true;
                startButton.innerText = "送信中...";
                const feedback = feedbackText.value;
                const processedResults = processResultsForGAS(results);
                const payload = {
                    elapsedTime: gameElapsedTime.toFixed(1),
                    age: userAge,
                    gender: userGender,
                    results: processedResults,
                    feedback: feedback
                };
                const success = await sendDataToGAS(payload);
                if (success) {
                    resetStartScreen(); 
                    startButton.disabled = false;
                } else {
                    startButton.disabled = false;
                    startButton.innerText = "送信失敗 - 再試行";
                }
                return;
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            if (Object.keys(audioBuffers).length < soundNames.length + 1) { 
                alert("まだ音声データを生成しています。"); return;
            }
            const age = ageSelect.value;
            const gender = genderSelect.value;
            if (!age || !gender) {
                formErrorMessage.classList.remove('hidden');
                return;
            }
            formErrorMessage.classList.add('hidden');
            userAge = age;
            userGender = gender;
            startGame();
        });
        function startGame() {
            startScreen.style.display = 'none';
            dodgeButton.classList.remove('hidden'); 
            gameMessage.classList.remove('hidden'); 
            resultsLog.classList.remove('hidden');  
            infoDisplay.classList.remove('hidden');
            currentQuestionIndex = 0;
            results = [];
            dodgeOffset = 0;
            isDodging = false;
            isWaitingToReturn = false;
            isReturning = false;
            isCollided = false; 
            collisionTimer = 0; 
            currentCubeZ = START_Z;
            gameStartTime = new Date(); 
            createTrialSet(); 
            startFirstTrial();
        }
        function startFirstTrial() {
            const trial = currentTrialSettings[currentQuestionIndex];
            if (!trial) return; 
            isWaitingToStart = true;
            startDelayTimer = 30 + Math.random() * 60; 
            playSound(trial.sound);
            infoDisplay.innerText = `第 1 問`;
            infoDisplay.style.color = 'white';
            gameMessage.textContent = "ぎりぎりで避けよう！"; 
            gameMessage.style.color = "white"; 
            resultsLog.innerHTML = ''; 
            gameRunning = true;
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function prepareNextTrial() {
            currentQuestionIndex++;
            if (currentQuestionIndex >= TOTAL_QUESTIONS) {
                finishGame();
                return;
            }
            const trial = currentTrialSettings[currentQuestionIndex];
            if (!trial) {
                finishGame();
                return;
            }
            isWaitingToStart = true;
            startDelayTimer = 30 + Math.random() * 60; 
            infoDisplay.innerText = `第 ${currentQuestionIndex + 1} 問`;
            infoDisplay.style.color = 'white';
            gameMessage.textContent = "ぎりぎりで避けよう！"; 
            gameMessage.style.color = "white"; 
            playSound(trial.sound); 
        }
        function handleDodgeInput() {
            if (!gameRunning || isDodging || isWaitingToReturn || isReturning || isCollided || isWaitingToStart) {
                return;
            }
            const remainingDistance = Math.max(0, currentCubeZ - END_Z);
            const scoreMeters = remainingDistance / METER_CONVERSION_RATIO;
            infoDisplay.innerText = `結果: 残り ${scoreMeters.toFixed(1)} m`;
            infoDisplay.style.color = '#00FF00';
            gameMessage.textContent = "回避成功！"; 
            gameMessage.style.color = "#00FF00"; 
            recordResult(scoreMeters, false);
            updateResultsLog(scoreMeters, false); 
            isDodging = true;
        }
        document.addEventListener('keydown', (event) => {
            if (event.code === 'Space') { 
                event.preventDefault(); 
                handleDodgeInput();
            }
        });
        dodgeButton.addEventListener('click', () => {
             if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            handleDodgeInput();
        });
        function handleCollision() {
            if (isCollided) return; 
            isCollided = true;
            collisionTimer = COLLISION_ANIMATION_DURATION; 
            infoDisplay.innerText = `衝突 (残り 0.0 m)`;
            infoDisplay.style.color = '#FF0000';
            gameMessage.textContent = "衝突！"; 
            gameMessage.style.color = "#FF0000"; 
            recordResult(0, true);
            updateResultsLog(0, true); 
            
            if (gainNode) {
                gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            }
        }
        function recordResult(scoreMeters, collided) {
            const trial = currentTrialSettings[currentQuestionIndex];
            if (!trial) return;
            const resultData = {
                question: currentQuestionIndex + 1,
                type: trial.type,
                color: trial.color,
                sound: (trial.sound === NO_SOUND) ? ENGINE_SOUND_NAME : trial.sound, 
                scoreMeters: scoreMeters,
                collided: collided
            };
            results.push(resultData);
            console.log(`【記録 ${resultData.question}】`, resultData);
        }
        function updateResultsLog(scoreMeters, collided) {
            const newLogEntry = document.createElement('div');
            newLogEntry.classList.add('log-entry');
            if (collided) {
                newLogEntry.style.color = '#FF4444'; 
                newLogEntry.textContent = `Q${currentQuestionIndex + 1}: 衝突!`;
            } else {
                newLogEntry.style.color = '#88FF88'; 
                newLogEntry.textContent = `Q${currentQuestionIndex + 1}: ${scoreMeters.toFixed(1)} m`;
            }
            resultsLog.prepend(newLogEntry); 
            while (resultsLog.children.length > 5) {
                resultsLog.removeChild(resultsLog.lastChild);
            }
        }
        function finishGame() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            stopCurrentSound(false); 
            gameElapsedTime = (new Date() - gameStartTime) / 1000; 
            startScreen.style.display = 'flex';
            startButton.innerText = 'もう一度行う';
            startButton.classList.remove('hidden'); 
            dodgeButton.classList.add('hidden'); 
            gameMessage.classList.add('hidden'); 
            resultsLog.classList.add('hidden');  
            infoDisplay.classList.add('hidden'); 
            userInfoForm.classList.add('hidden'); 
            instructionsDiv.style.textAlign = 'left'; 
            feedbackForm.classList.remove('hidden'); 
            
            console.log("--- 全試行結果 ---");
            console.table(results);
            let resultHTML = '<h2>全試行結果</h2>';
            let totalScore = 0;
            results.forEach(res => {
                totalScore += res.scoreMeters;
            });
            let averageScore = totalScore / results.length;
            resultHTML += `<h3 style="color: #00FF00;">平均スコア: ${averageScore.toFixed(1)} m (経過時間: ${gameElapsedTime.toFixed(1)} 秒)</h3>`;
            resultHTML += '<table>';
            resultHTML += '<tr><th>問</th><th>タイプ</th><th>条件</th><th>スコア (m)</th></tr>';
            results.forEach(res => {
                resultHTML += '<tr>';
                resultHTML += `<td>${res.question}</td>`;
                resultHTML += `<td>${res.type}</td>`;
                let condition = '';
                // ★(変更) 基準(QQ)の表示を調整
                if (res.type === '基準') { 
                    condition = 'QQ (グレー)';
                } else if (res.type === '色') {
                    condition = `<div class="color-chip" style="background-color:${res.color};"></div>`;
                } else if (res.type === '音') {
                    condition = res.sound.replace(' Noise', '');
                }
                resultHTML += `<td>${condition}</td>`;
                resultHTML += `<td>${res.collided ? '<span style="color:red;">衝突 (0.0)</span>' : res.scoreMeters.toFixed(1)}</td>`;
                resultHTML += '</tr>';
            });
            resultHTML += '</table>';
            instructionsDiv.innerHTML = resultHTML;
        }
        function resetStartScreen() {
            instructionsDiv.innerHTML = `
                <p>
                    物体が迫ってきます。<br>
                    下のハンドルにぶつかると思った瞬間に<br>
                    [スペースキー] または [回避ボタン] を押してください。
                </p>`;
            instructionsDiv.style.textAlign = 'center';
            feedbackForm.classList.add('hidden');
            userInfoForm.classList.remove('hidden');
            startButton.innerText = 'スタート';
            startButton.classList.remove('hidden');
            feedbackText.value = ''; 
        }

        // --- 8. GASへのデータ送信 (★修正あり) ---
        function processResultsForGAS(resultsArray) {
            const data = {};
            // ★(変更) QBaseを削除し、QQに対応
            const colorMap = {
                // '#FFFFFF' (BASE_COLOR) は音響試行のベースなので、マッピング不要
                '#FF0000': 'QR', '#00FF00': 'QG', '#0000FF': 'QB',
                '#00FFFF': 'QC', '#FF00FF': 'QM', '#FFFF00': 'QY'
            };
            const soundMap = {
                'White Noise': 'Qm1', 'Pink Noise': 'Qm2', 'Brown Noise': 'Qm3'
            };
            resultsArray.forEach(res => {
                let key = null;
                // ★(変更) '基準' (QQ) のマッピング
                if (res.type === '基準') {
                    key = 'QQ';
                } else if (res.type === '色') {
                    key = colorMap[res.color];
                } else if (res.type === '音') {
                    key = soundMap[res.sound];
                }
                if (key) {
                    data[key] = res.collided ? 0.0 : res.scoreMeters;
                }
            });
            return data;
        }

        // (sendDataToGAS 関数は変更なし)
        async function sendDataToGAS(payload) {
            console.log("Sending payload to GAS:", payload);
            try {
                const response = await fetch(GAS_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'text/plain', 
                    },
                    body: JSON.stringify(payload) 
                });
                const result = await response.json(); 
                if (result.status === "success") {
                    console.log("GAS success:", result.message);
                    return true; 
                } else {
                    console.error('GAS Error:', result.message, result.stack);
                    alert("サーバー側でのデータ記録に失敗しました。\n" + result.message);
                    return false;
                }
            } catch (error) {
                console.error('Error sending data to GAS:', error);
                alert("データの送信に失敗しました。ネットワーク接続を確認してください。\n" + error.message);
                return false; 
            }
        }
        // ★★★★★ 修正ここまで ★★★★★


        // --- 実行 ---
        generateSounds();
        draw(); 

    </script>
</body>
</html>