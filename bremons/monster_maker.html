<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BREMONS - GENESIS</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style>
        /* === 裏モード専用スタイル === */
        body {
            margin: 0; padding: 0;
            font-family: 'DotGothic16', sans-serif;
            background-color: #050505; color: #fff;
            display: flex; justify-content: center;
            height: 100dvh; overflow: hidden;
            user-select: none;
        }

        .game-container {
            width: 100%; max-width: 480px; height: 100%;
            position: relative; overflow: hidden;
            box-shadow: 0 0 30px rgba(142, 68, 173, 0.2);
            display: flex; flex-direction: column;
        }

        /* 背景: JSでアニメーション設定を直接書き換えます */
        .scrolling-bg {
            position: absolute; top: -50%; left: 0; width: 100%; height: 200%;
            background-image: url('./nightgame/background2.png');
            background-size: cover; background-repeat: repeat-y;
            z-index: 0;
            /* 初期状態 */
            animation: scrollSpace 60s linear infinite;
            filter: contrast(1.1) brightness(0.8);
            /* 色の変化を瞬時に行うためtransitionは設定しない */
        }
        @keyframes scrollSpace { from { transform: translateY(0); } to { transform: translateY(50%); } }
        @keyframes scrollSpaceRev { from { transform: translateY(50%); } to { transform: translateY(0); } }

        /* UIレイヤー */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            display: flex; flex-direction: column; align-items: center;
            padding: 10px; box-sizing: border-box;
            background: rgba(0, 0, 0, 0.4);
        }

        /* ヘッダー */
        .back-link {
            position: absolute; top: 15px; left: 15px;
            font-size: 14px; text-decoration: none; color: #fff;
            background: rgba(0,0,0,0.8); padding: 5px 10px;
            border: 1px solid #fff; border-radius: 4px;
        }

        .title-area { margin-top: 20px; text-align: center; margin-bottom: 10px; }
        .game-title {
            font-size: 48px; margin: 0; letter-spacing: 2px;
            background: linear-gradient(to right, #ff9a9e, #4facfe, #f093fb);
            -webkit-background-clip: text; background-clip: text; color: transparent;
            filter: drop-shadow(4px 4px 0px rgba(255, 255, 255, 0.2));
            animation: title-glitch 5s infinite;
        }
        /* ロゴのグリッチは維持 */
        @keyframes title-glitch {
            0%, 95% { transform: skew(0deg); }
            96% { transform: skew(10deg); filter: drop-shadow(-4px 0px 0px rgba(255, 0, 0, 0.8)); }
            97% { transform: skew(-10deg); filter: drop-shadow(4px 0px 0px rgba(0, 255, 255, 0.8)); }
            98% { transform: skew(0deg); }
        }
        .subtitle { font-size: 14px; color: #fff; margin-top: 5px; letter-spacing: 5px; opacity: 0.8; }

        /* コード入力エリア */
        .seed-box {
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #8e44ad; border-radius: 8px;
            padding: 8px; margin-bottom: 10px;
            display: flex; gap: 5px; width: 90%;
            box-shadow: 0 0 10px rgba(142, 68, 173, 0.3);
        }
        .seed-input {
            flex: 1; background: #000; border: 1px solid #555;
            color: #fff; font-family: inherit; font-size: 16px;
            padding: 4px; text-align: center; outline: none;
        }
        .icon-btn {
            background: #333; color: #fff; border: 1px solid #fff; cursor: pointer;
            padding: 5px 10px; font-size: 14px; border-radius: 4px;
        }
        .restore-btn {
            background: #8e44ad; color: #fff; border: 1px solid #fff;
            cursor: pointer; padding: 0 10px; font-weight: bold; border-radius: 4px;
        }

        /* ボタンエリア (中央上部) */
        .menu-area { width: 85%; display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
        
        .pixel-btn {
            font-family: 'DotGothic16', sans-serif; font-size: 18px;
            padding: 15px; width: 100%;
            background-color: #8e44ad; /* 紫 */
            color: #fff;
            border: 2px solid #fff; border-radius: 4px;
            cursor: pointer; text-align: center;
            box-shadow: 4px 4px 0 rgba(0,0,0,0.5);
            position: relative;
            clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%);
        }
        .pixel-btn:active { transform: translate(2px, 2px); box-shadow: 2px 2px 0 rgba(0,0,0,0.5); }
        
        /* 壊れたアニメーション (保存ボタンにも適用) */
        .broken-anim { animation: glitch-clip 2.5s infinite steps(1); }
        @keyframes glitch-clip {
            0%, 89% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); transform: translate(0,0); }
            90% { clip-path: polygon(0 0, 80% 0, 80% 100%, 0 100%); transform: translate(-2px, 1px); } /* 右欠け */
            92% { clip-path: polygon(5% 0, 100% 0, 100% 100%, 5% 100%); transform: translate(2px, -1px); } /* 左欠け */
            94% { clip-path: polygon(0 10%, 100% 0, 95% 100%, 0% 90%); transform: skewX(5deg); } /* 歪み */
            96% { clip-path: polygon(0 0, 100% 0, 100% 40%, 0 40%, 0 60%, 100% 60%, 100% 100%, 0 100%); } /* 分割 */
            98% { clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); transform: translate(0,0); }
        }

        .save-btn { background-color: #3498db; border-color: #fff; display: none; }

        /* モンスターカプセル */
        .monster-capsule {
            width: 200px; height: 200px;
            border: 4px solid #fff; border-radius: 16px;
            background: rgba(0, 0, 0, 0.6);
            display: flex; justify-content: center; align-items: center;
            box-shadow: inset 0 0 20px rgba(255,255,255,0.2);
            position: relative;
            margin-bottom: 5px;
        }
        canvas { image-rendering: pixelated; width: 100%; height: 100%; z-index: 5; }

        .status-text { font-size: 32px; color: #f1c40f; text-shadow: 2px 2px 0 #000; margin-top: 10px; }
        .sub-text { font-size: 14px; color: #ccc; }
        
        .hidden { display: none; }
    </style>
</head>
<body>

    <div class="game-container">
        <div class="scrolling-bg" id="bgLayer"></div>

        <div class="ui-layer">
            <a href="index.html" class="back-link">←戻る</a>

            <div class="title-area">
                <h1 class="game-title">BREMONS</h1>
                <span class="subtitle">- GENESIS -</span>
            </div>

            <div class="seed-box">
                <input type="text" id="seedInput" class="seed-input" placeholder="BM-XXXX-XXXX">
                <button class="icon-btn" onclick="copySeed()">コピー</button>
                <button class="restore-btn" onclick="loadFromInput()">復元</button>
            </div>

            <div class="menu-area">
                <button id="recordBtn" class="pixel-btn broken-anim" onclick="startSequence()">
                    音で生成する (5秒)
                </button>
                <button id="saveBtn" class="pixel-btn save-btn broken-anim" onclick="saveImage()">
                    画像を保存する
                </button>
            </div>

            <div class="monster-capsule">
                <canvas id="monCanvas" width="20" height="20"></canvas>
            </div>

            <div class="status-text" id="percentDisplay">0%</div>
            <div class="sub-text" id="statusMsg">音声入力待機中...</div>
        </div>
    </div>

<script>
        // パステルカラーパレット
        const SCALE_COLORS = [
            { name: "C",  hex: "#FF9AA2", eye: "#C85A62" }, { name: "C#", hex: "#FFB7B2", eye: "#D67C77" },
            { name: "D",  hex: "#FFDAC1", eye: "#D4A88F" }, { name: "D#", hex: "#FFE6A7", eye: "#C9B475" },
            { name: "E",  hex: "#FFF5BA", eye: "#C4BD87" }, { name: "F",  hex: "#C1E1C1", eye: "#8FAB8F" },
            { name: "F#", hex: "#B2E0E6", eye: "#81ADB3" }, { name: "G",  hex: "#AEEEEE", eye: "#7FBDBD" },
            { name: "G#", hex: "#ADD8E6", eye: "#7FA8B6" }, { name: "A",  hex: "#B4C6E7", eye: "#8396B7" },
            { name: "A#", hex: "#C3B1E1", eye: "#917FB1" }, { name: "B",  hex: "#E6B0AA", eye: "#B37D77" }
        ];

        let audioContext, analyser, dataArray;
        let isProcessing = false;
        let glitchAudioCtx = null, glitchGain = null;

        const canvas = document.getElementById('monCanvas');
        const ctx = canvas.getContext('2d');
        const percentDisplay = document.getElementById('percentDisplay');
        const statusMsg = document.getElementById('statusMsg');
        const recordBtn = document.getElementById('recordBtn');
        const saveBtn = document.getElementById('saveBtn');
        const seedInput = document.getElementById('seedInput');
        const bgLayer = document.getElementById('bgLayer');

        // --- 背景制御: 動きと色の急変 ---
        function glitchBackground() {
            const nextTime = Math.random() * 2000 + 1000; // 1~3秒ごとに変化
            
            // 1. 動きの急変 (通常 / 逆走 / 爆速 / 停止)
            const rMove = Math.random();
            if(rMove < 0.1) {
                bgLayer.style.animationDirection = 'reverse';
                bgLayer.style.animationDuration = '2s'; // 爆速逆走
            } else if(rMove < 0.2) {
                bgLayer.style.animationPlayState = 'paused'; // 急停止
            } else if(rMove < 0.3) {
                bgLayer.style.animationDuration = '0.5s'; // 超高速
            } else {
                bgLayer.style.animationDirection = 'normal';
                bgLayer.style.animationPlayState = 'running';
                bgLayer.style.animationDuration = '60s'; // 通常
            }

            // 2. 色の急変 (パッと切り替わる)
            const rColor = Math.random();
            if(rColor > 0.8) {
                // 異常色 (色相回転 + コントラスト強)
                const hue = Math.floor(Math.random() * 360);
                bgLayer.style.filter = `hue-rotate(${hue}deg) contrast(1.5) saturate(1.5)`;
            } else {
                // 通常色 (少し暗め)
                bgLayer.style.filter = `hue-rotate(0deg) contrast(1.1) brightness(0.8)`;
            }

            setTimeout(glitchBackground, nextTime);
        }
        glitchBackground();

        // --- BGM制御 (録音中は停止) ---
        function initGlitchSound() {
            if(glitchAudioCtx) return;
            glitchAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const bufferSize = glitchAudioCtx.sampleRate; 
            const buffer = glitchAudioCtx.createBuffer(1, bufferSize, glitchAudioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.1;

            const noise = glitchAudioCtx.createBufferSource();
            noise.buffer = buffer; noise.loop = true;
            
            const filter = glitchAudioCtx.createBiquadFilter();
            filter.type = 'lowpass'; filter.frequency.value = 600;
            
            glitchGain = glitchAudioCtx.createGain();
            glitchGain.gain.value = 0.03;

            setInterval(() => {
                 if(glitchGain.gain.value > 0) {
                     glitchGain.gain.setTargetAtTime(Math.random() * 0.04 + 0.01, glitchAudioCtx.currentTime, 0.5);
                 }
            }, 500);

            noise.connect(filter).connect(glitchGain).connect(glitchAudioCtx.destination);
            noise.start();
        }
        document.body.addEventListener('click', initGlitchSound, { once: true });

        // マイク使用中は完全にミュート
        function stopBGM() { if(glitchGain) glitchGain.gain.value = 0; }
        function startBGM() { if(glitchGain) glitchGain.gain.value = 0.03; }

        // --- 生成シーケンス ---
        async function startSequence() {
            if(isProcessing) return;
            isProcessing = true;
            stopBGM(); // ★BGM停止
            
            recordBtn.innerText = "解析中..."; 
            saveBtn.style.display = 'none';
            percentDisplay.innerText = "0%"; 
            statusMsg.innerText = "音声を入力してください...";

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 2048;
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                let startTime = Date.now();
                let noteVotes = new Array(12).fill(0);
                let pitchSum = 0; let pitchCount = 0;

                const loop = setInterval(() => {
                    let elapsed = Date.now() - startTime;
                    let progress = Math.min(100, Math.floor((elapsed / 5000) * 100));
                    percentDisplay.innerText = progress + "%";

                    analyser.getByteFrequencyData(dataArray);
                    let maxVal = 0; let maxIndex = 0;
                    for(let i=10; i<200; i++) { if(dataArray[i] > maxVal) { maxVal = dataArray[i]; maxIndex = i; } }
                    const vol = maxVal;
                    
                    if(vol > 35) {
                        const freq = maxIndex * (audioContext.sampleRate / analyser.fftSize);
                        const n = 12 * Math.log2(freq / 440) + 69;
                        const currentNote = (Math.round(n) % 12 + 12) % 12;
                        const currentPitch = Math.min(255, Math.max(0, (maxIndex - 10) * 1.5));
                        noteVotes[currentNote] += vol;
                        pitchSum += currentPitch; pitchCount++;
                    }

                    if(elapsed < 4500) {
                        drawMonster(Math.floor(Math.random()*12), Math.floor(Math.random()*255), Math.floor(Math.random()*255), Math.floor(Math.random()*255));
                    }
                    else {
                        clearInterval(loop);
                        let maxV = -1; let finalNote = 0;
                        for(let i=0; i<12; i++) if(noteVotes[i] > maxV) { maxV = noteVotes[i]; finalNote = i; }
                        if(maxV < 100) finalNote = Math.floor(Math.random()*12);
                        const finalPitch = (pitchCount > 0) ? Math.floor(pitchSum / pitchCount) : 128;
                        
                        finishSequence(stream, finalNote, finalPitch);
                    }
                }, 50);

            } catch(e) {
                alert("マイクエラー: " + e);
                isProcessing = false;
                startBGM();
                recordBtn.innerText = "再試行"; 
                statusMsg.innerText = "デバイスエラー";
            }
        }

        function finishSequence(stream, note, pitch) {
            stream.getTracks().forEach(t => t.stop());
            isProcessing = false;
            startBGM(); // ★BGM再開
            
            recordBtn.innerText = "再生成 (5秒)"; 
            saveBtn.style.display = 'block';
            percentDisplay.innerText = "完了"; 
            statusMsg.innerText = "生成体データ確定";

            let finalType = Math.floor(Math.random() * 255);
            let finalRnd = Math.floor(Math.random() * 255);

            let p1 = toHex(note); let p2 = toHex(pitch); 
            let p3 = toHex(finalType); let p4 = toHex(finalRnd);
            seedInput.value = `BM-${p1}${p2}-${p3}${p4}`;
            
            drawMonster(note, pitch, finalType, finalRnd);
        }

        function saveImage() {
            const link = document.createElement('a');
            link.download = 'bremons.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        // --- ★完全同期復元ロジック (Xorshift32) ---
        class Xorshift32 {
            constructor(seed) {
                this.state = seed | 0; 
                if (this.state === 0) this.state = 0xdeadbeef;
            }
            next() {
                let x = this.state;
                x ^= x << 13; x ^= x >>> 17; x ^= x << 5;
                this.state = x;
                return (x >>> 0) / 4294967296;
            }
        }

        function drawMonster(noteIdx, pitchVal, typeVal, rndVal) {
            const colorData = SCALE_COLORS[noteIdx % 12];
            const mainColor = colorData.hex;
            const eyeColor = colorData.eye;
            const shadowColor = adjustBrightness(mainColor, -25);
            const outlineColor = adjustBrightness(mainColor, -40);

            ctx.clearRect(0, 0, 20, 20); 

            // ★シード生成: 4つの値を結合
            const masterSeed = (noteIdx << 24) ^ (pitchVal << 16) ^ (typeVal << 8) ^ rndVal;
            const rng = new Xorshift32(masterSeed);

            const gridSize = 20;
            const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));
            const centerX = 9.5; const centerY = 10.5; 
            
            let squash = 0.7 + (pitchVal / 255) * 0.3;
            const baseRadiusW = 8.0; const baseRadiusH = 8.0 * squash;
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dx = x - centerX; const dy = y - centerY;
                    let dynamicRadiusW = baseRadiusW * (1.0 + dy * 0.04);
                    if ((dx*dx)/(dynamicRadiusW*dynamicRadiusW) + (dy*dy)/(baseRadiusH*baseRadiusH) <= 0.95) grid[y][x] = 2; 
                }
            }

            // パーツ (RNGで決定) - ★P4(rndVal)を使ってパーツを決める
            const partsType = Math.floor(rng.next() * 4); 
            
            let bodyTopY = 0;
            for(let y=0; y<gridSize/2; y++) { if(grid[y][9] === 2) { bodyTopY = y; break; } }
            const earX = Math.floor(centerX - 2); const earBaseY = bodyTopY;
            if (earBaseY >= 1) {
                if (partsType === 0) { grid[earBaseY][earX]=2; grid[earBaseY][earX-1]=2; grid[earBaseY-1][earX]=2; grid[earBaseY-1][earX-1]=2; grid[earBaseY][earX-1]=4; } 
                else if (partsType === 1) { grid[earBaseY-1][earX]=2; grid[earBaseY-2][earX]=2; grid[earBaseY-1][earX]=4; } 
                else if (partsType === 2) { grid[earBaseY][earX-1]=2; grid[earBaseY-1][earX-1]=2; grid[earBaseY-1][earX-2]=2; grid[earBaseY][earX-1]=4; }
            }
            
            // 足 (RNGで決定)
            let bodyBottomY = gridSize-1;
            for(let y=gridSize-1; y>gridSize/2; y--) { if(grid[y][9] === 2) { bodyBottomY = y; break; } }
            const legX = Math.floor(centerX - 3);
            if (bodyBottomY < gridSize-1 && rng.next() > 0.3) {
                grid[bodyBottomY+1][legX] = 2; grid[bodyBottomY+2][legX] = 1; 
                grid[bodyBottomY+1][legX-1] = 2; grid[bodyBottomY+2][legX-1] = 1;
            }

            for (let y=0; y<gridSize; y++) for(let x=0; x<10; x++) if(grid[y][x]!==0) grid[y][19-x]=grid[y][x];
            const finalGrid = JSON.parse(JSON.stringify(grid));
            for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) if(grid[y][x]===2 || grid[y][x]===4) { let isEdge=false; [[0,-1],[0,1],[-1,0],[1,0]].forEach(([nx,ny])=>{if(!grid[y+ny]||grid[y+ny][x+nx]===0)isEdge=true;}); if(isEdge)finalGrid[y][x]=1; }
            for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) if(finalGrid[y][x]===2) { if(x>centerX+4 && y>centerY+3 && (x+y)%2===0) finalGrid[y][x]=4; }
            for (let y=0; y<gridSize; y++) for(let x=0; x<gridSize; x++) { const val=finalGrid[y][x]; if(val!==0){ if(val===1)ctx.fillStyle=outlineColor; else if(val===2)ctx.fillStyle=mainColor; else if(val===4)ctx.fillStyle=shadowColor; ctx.fillRect(x,y,1,1); } }

            const eyeY = Math.floor(centerY); const eyeX_L = 6; const eyeX_R = 12; 
            let eyePattern = typeVal % 3;
            drawSpecifiedEye(ctx, eyeX_L, eyeY, eyeColor, shadowColor, eyePattern);
            drawSpecifiedEye(ctx, eyeX_R, eyeY, eyeColor, shadowColor, eyePattern, false);
        }

        function drawSpecifiedEye(ctx, x, y, color, shadow, pattern, isRight=false) {
            ctx.fillStyle = "#fff";
            if (pattern === 0) { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = color; ctx.fillRect(x, y+2, 2, 2); } 
            else if (pattern === 1) { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); ctx.fillStyle = color; ctx.fillRect(x, y+3, 2, 1); } 
            else { ctx.fillRect(x, y, 2, 2); ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); ctx.fillStyle = color; ctx.fillRect(x, y+3, 2, 1); const decoX = x + 2; ctx.fillStyle = shadow; ctx.fillRect(decoX, y+2, 1, 1); ctx.fillStyle = color; ctx.fillRect(decoX, y+1, 1, 1); }
        }

        function toHex(n) { return Math.floor(n||0).toString(16).padStart(2,'0').toUpperCase(); }
        function adjustBrightness(hex, p) {
            let r = parseInt(hex.slice(1,3), 16); let g = parseInt(hex.slice(3,5), 16); let b = parseInt(hex.slice(5,7), 16);
            r = Math.max(0, Math.min(255, r + Math.round(2.55 * p))); g = Math.max(0, Math.min(255, g + Math.round(2.55 * p))); b = Math.max(0, Math.min(255, b + Math.round(2.55 * p)));
            return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
        }

        function copySeed() {
            seedInput.select(); document.execCommand("copy");
            statusMsg.innerText = "コピーしました";
        }

        function loadFromInput() {
            const val = seedInput.value.trim().toUpperCase();
            if(/^BM-[0-9A-F]{4}-[0-9A-F]{4}$/.test(val)) {
                // 【修正】以前のRegex置換では "BM" の "B" (Hex:11) が残ってしまい、桁ズレを起こしていた
                // ここで確実にハイフンで区切り、数値部分だけを抽出する
                const parts = val.split('-'); // ["BM", "XXXX", "XXXX"]
                const raw = parts[1] + parts[2];

                const p1 = parseInt(raw.substring(0,2), 16);
                const p2 = parseInt(raw.substring(2,4), 16);
                const p3 = parseInt(raw.substring(4,6), 16);
                const p4 = parseInt(raw.substring(6,8), 16);
                
                drawMonster(p1, p2, p3, p4);
                
                percentDisplay.innerText = "復元完了";
                statusMsg.innerText = "データ整合性確認OK";
                saveBtn.style.display = 'block';
            } else {
                alert("コードが無効です (BM-XXXX-XXXX)");
            }
        }
    </script>
</body>
</html>