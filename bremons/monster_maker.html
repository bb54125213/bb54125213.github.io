<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BREMONS MAKER - FINAL CUTE VER 3</title>
    <link href="https://fonts.googleapis.com/css2?family=DotGothic16&display=swap" rel="stylesheet">
    <style>
        body {
            background: #050505; color: #fff; font-family: 'DotGothic16', sans-serif;
            text-align: center; height: 100vh; margin: 0; overflow: hidden;
            display: flex; flex-direction: column; align-items: center;
        }
        .maker-container {
            width: 100%; max-width: 500px; height: 100%;
            display: flex; flex-direction: column; padding: 15px; box-sizing: border-box;
            background: radial-gradient(circle at center, #2a2a2a 0%, #000 100%);
        }
        
        .phase-bar {
            display: flex; justify-content: space-between; width: 100%; margin-bottom: 10px;
            background: #222; border-radius: 20px; padding: 4px; border: 1px solid #444;
        }
        .phase-step {
            flex: 1; text-align: center; font-size: 12px; padding: 4px 0;
            border-radius: 16px; color: #555; transition: all 0.3s;
        }
        .phase-step.active { background: #fff; color: #000; font-weight: bold; box-shadow: 0 0 10px #fff; }
        .phase-step.locked { background: #333; color: #888; border: 1px solid #555; }

        .monster-capsule {
            width: 240px; height: 240px; margin: 0 auto;
            border: 4px solid #444; border-radius: 16px;
            background: #111; position: relative;
            box-shadow: inset 0 0 30px rgba(0,0,0,0.8);
            display: flex; justify-content: center; align-items: center;
            overflow: hidden; transition: border-color 0.2s, box-shadow 0.2s;
        }
        
        canvas { image-rendering: pixelated; width: 100%; height: 100%; z-index: 2; }

        .scan-line {
            position: absolute; top: 0; left: 0; width: 100%; height: 2px;
            background: rgba(255,255,255,0.5); display: none; z-index: 3;
        }
        .scanning .scan-line { display: block; animation: scanMove 1.5s infinite linear; }

        @keyframes lockFlash { 0% { transform: scale(1); filter: brightness(1.5); } 50% { transform: scale(1.05); } 100% { transform: scale(1); filter: brightness(1); } }
        .locked-anim { animation: lockFlash 0.3s ease-out; }

        .info-panel {
            background: #111; border: 1px solid #333; border-radius: 8px;
            margin: 15px 0; padding: 10px; min-height: 60px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        .main-status { font-size: 24px; font-weight: bold; text-shadow: 0 0 5px currentColor; }
        .sub-status { font-size: 12px; color: #888; margin-top: 5px; }

        .control-panel { margin-top: auto; width: 100%; display: flex; flex-direction: column; gap: 10px; }
        .btn-record {
            width: 100%; padding: 15px; font-size: 18px; border-radius: 8px; cursor: pointer;
            border: 2px solid #e74c3c; background: rgba(231, 76, 60, 0.1); color: #e74c3c;
            font-family: inherit; transition: all 0.1s; display: flex; align-items: center; justify-content: center; gap: 10px;
        }
        .btn-record:active { transform: scale(0.98); }
        .btn-record.processing { background: #333; border-color: #555; color: #aaa; pointer-events: none; }

        .seed-box { background: #222; padding: 8px; border-radius: 8px; border: 1px solid #444; }
        .seed-input-group { display: flex; gap: 5px; }
        .seed-input {
            flex: 1; background: #000; border: 1px solid #555; color: #2ecc71;
            font-family: 'DotGothic16', sans-serif; font-size: 14px; text-align: center;
            padding: 5px; letter-spacing: 1px;
        }
        .copy-btn { width: 36px; background: #333; color: #fff; border: 1px solid #555; cursor: pointer; border-radius: 4px; }
        .btn-load {
            width: 100%; margin-top: 5px; padding: 8px; font-size: 14px; border-radius: 4px; cursor: pointer;
            border: 1px solid #3498db; background: rgba(52, 152, 219, 0.2); color: #3498db; font-family: inherit;
        }

        @keyframes scanMove { 0% { top: 0%; opacity: 0; } 50% { opacity: 1; } 100% { top: 100%; opacity: 0; } }
    </style>
</head>
<body>

    <div class="maker-container">
        <div class="phase-bar">
            <div id="step1" class="phase-step">â‘  è‰²(éŸ³éš)</div>
            <div id="step2" class="phase-step">â‘¡ å½¢(é«˜ã•)</div>
            <div id="step3" class="phase-step">â‘¢ ç›®(è£…é£¾)</div>
        </div>

        <div class="monster-capsule" id="capsule">
            <div class="scan-line"></div>
            <canvas id="monCanvas" width="20" height="20"></canvas>
        </div>

        <div class="info-panel">
            <div id="mainStatus" class="main-status" style="color:#555">---</div>
            <div id="subStatus" class="sub-status">ã€ŒéŸ³ã§ç”Ÿæˆã€ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</div>
        </div>

        <div class="control-panel">
            <button id="recordBtn" class="btn-record" onclick="startSequence()">
                <span>ğŸ™ï¸</span> éŸ³ã§ç”Ÿæˆ (5ç§’)
            </button>
            
            <div class="seed-box">
                <div class="seed-input-group">
                    <input type="text" id="seedInput" class="seed-input" placeholder="BM-XXXX-XXXX" maxlength="15">
                    <button class="copy-btn" onclick="copySeed()">ğŸ“‹</button>
                </div>
                <button class="btn-load" onclick="loadFromSeed()">
                    ãƒŠãƒ³ãƒãƒ¼ã‹ã‚‰å¾©å…ƒ
                </button>
            </div>
            
            <a href="stage_select.html" style="color:#444; text-decoration:none; font-size:12px; display:block; margin-top:5px;">â† ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸</a>
        </div>
    </div>

    <script>
        const SCALE_COLORS = [
            { name: "C (ãƒ‰)",  hex: "#FF9AA2", eye: "#C85A62" }, 
            { name: "C#",      hex: "#FFB7B2", eye: "#D67C77" }, 
            { name: "D (ãƒ¬)",  hex: "#FFDAC1", eye: "#D4A88F" }, 
            { name: "D#",      hex: "#FFE6A7", eye: "#C9B475" }, 
            { name: "E (ãƒŸ)",  hex: "#FFF5BA", eye: "#C4BD87" }, 
            { name: "F (ãƒ•ã‚¡)", hex: "#C1E1C1", eye: "#8FAB8F" }, 
            { name: "F#",      hex: "#B2E0E6", eye: "#81ADB3" }, 
            { name: "G (ã‚½)",  hex: "#AEEEEE", eye: "#7FBDBD" }, 
            { name: "G#",      hex: "#ADD8E6", eye: "#7FA8B6" }, 
            { name: "A (ãƒ©)",  hex: "#B4C6E7", eye: "#8396B7" }, 
            { name: "A#",      hex: "#C3B1E1", eye: "#917FB1" }, 
            { name: "B (ã‚·)",  hex: "#E6B0AA", eye: "#B37D77" }  
        ];

        let audioContext, analyser, dataArray;
        let isProcessing = false;
        
        let lockedNote = -1;  
        let lockedPitchVal = -1; 

        const canvas = document.getElementById('monCanvas');
        const ctx = canvas.getContext('2d');
        const capsule = document.getElementById('capsule');
        const mainStatus = document.getElementById('mainStatus');
        const subStatus = document.getElementById('subStatus');
        const seedInput = document.getElementById('seedInput');
        const step1 = document.getElementById('step1');
        const step2 = document.getElementById('step2');
        const step3 = document.getElementById('step3');

        async function startSequence() {
            if(isProcessing) return;
            isProcessing = true;
            document.getElementById('recordBtn').classList.add('processing');
            document.getElementById('recordBtn').innerHTML = "è§£æä¸­...";

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                analyser.fftSize = 2048;
                dataArray = new Uint8Array(analyser.frequencyBinCount);

                capsule.classList.add('scanning');
                
                lockedNote = -1;
                lockedPitchVal = -1;
                let startTime = Date.now();
                
                let noteVotes = new Array(12).fill(0);
                let pitchSum = 0;
                let pitchCount = 0;

                const loop = setInterval(() => {
                    let elapsed = Date.now() - startTime;
                    analyser.getByteFrequencyData(dataArray);

                    let maxVal = 0; let maxIndex = 0;
                    for(let i=10; i<200; i++) {
                        if(dataArray[i] > maxVal) { maxVal = dataArray[i]; maxIndex = i; }
                    }
                    const vol = maxVal;
                    let currentNote = -1;
                    let currentPitchVal = Math.min(255, Math.max(0, (maxIndex - 10) * 1.5));

                    if(vol > 35) {
                        const freq = maxIndex * (audioContext.sampleRate / analyser.fftSize);
                        const n = 12 * Math.log2(freq / 440) + 69;
                        currentNote = (Math.round(n) % 12 + 12) % 12;
                        noteVotes[currentNote] += vol;
                        
                        pitchSum += currentPitchVal;
                        pitchCount++;
                    }

                    // --- ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ ---
                    if(elapsed < 2000) {
                        setStepUI(1);
                        subStatus.innerText = "æ­Œã†éŸ³éšã§ã€Œè‰²ã€ãŒæ±ºã¾ã‚Šã¾ã™";
                        let tempNote = (vol > 35) ? currentNote : (Math.floor(elapsed/100) % 12);
                        if(vol > 35) {
                            drawMonster(tempNote, 128, 0, 0);
                            updateStatusColor(tempNote);
                        } else {
                            drawMonster(Math.floor(Math.random()*12), 128, 0, 0);
                        }
                    }
                    else if(lockedNote === -1) {
                        let maxV = -1;
                        for(let i=0; i<12; i++) {
                            if(noteVotes[i] > maxV) { maxV = noteVotes[i]; lockedNote = i; }
                        }
                        if(maxV < 100) lockedNote = Math.floor(Math.random()*12);
                        capsule.classList.add('locked-anim');
                        setTimeout(()=>capsule.classList.remove('locked-anim'), 300);
                        updateStatusColor(lockedNote);
                        subStatus.innerText = "è‰²ãŒæ±ºå®šã—ã¾ã—ãŸï¼";
                    }
                    else if(elapsed < 3500) {
                        setStepUI(2);
                        subStatus.innerText = "å£°ã®é«˜ã•ã§ã€Œæ½°ã‚Œå…·åˆã€ãŒå¤‰åŒ–...";
                        drawMonster(lockedNote, currentPitchVal, 0, 0);
                    }
                    else if(lockedPitchVal === -1) {
                        lockedPitchVal = (pitchCount > 0) ? Math.floor(pitchSum / pitchCount) : 128;
                        capsule.classList.add('locked-anim');
                        setTimeout(()=>capsule.classList.remove('locked-anim'), 300);
                    }
                    else if(elapsed < 5000) {
                        setStepUI(3);
                        subStatus.innerText = "ä»•ä¸Šã’ä¸­...";
                        let rndType = Math.floor(Math.random() * 255);
                        let rndParts = Math.floor(Math.random() * 255);
                        drawMonster(lockedNote, lockedPitchVal, rndType, rndParts);
                    }
                    else {
                        clearInterval(loop);
                        finishSequence(stream, lockedNote, lockedPitchVal);
                    }
                }, 50);

            } catch(e) {
                alert("ãƒã‚¤ã‚¯ã‚¨ãƒ©ãƒ¼: " + e);
                isProcessing = false;
            }
        }

        function finishSequence(stream, note, pitchVal) {
            stream.getTracks().forEach(t => t.stop());
            capsule.classList.remove('scanning');
            isProcessing = false;
            setStepUI(0);
            document.getElementById('recordBtn').classList.remove('processing');
            document.getElementById('recordBtn').innerHTML = "<span>ğŸ™ï¸</span> éŸ³ã§ç”Ÿæˆ (5ç§’)";

            let rndVal = Math.floor(Math.random() * 255);
            let typeVal = rndVal; 

            let p1 = toHex(note); let p2 = toHex(pitchVal); let p3 = toHex(typeVal); let p4 = toHex(rndVal);
            let finalSeed = `BM-${p1}${p2}-${p3}${p4}`;
            
            seedInput.value = finalSeed;
            subStatus.innerText = "ç”Ÿæˆå®Œäº†ï¼ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ä¿å­˜ã—ã‚ˆã†";
            capsule.classList.add('locked-anim');
            drawMonster(note, pitchVal, typeVal, rndVal);
        }

        // --- æç”»é–¢æ•° (ä¿®æ­£ç‰ˆ: æŒ‡å®šç›®ï¼†æ–°ã‚«ãƒ©ãƒ¼ãƒ«ãƒ¼ãƒ«) ---
        function drawMonster(noteIdx, pitchVal, typeVal, rndVal) {
            const safeIdx = noteIdx % 12;
            const colorData = SCALE_COLORS[safeIdx];
            const mainColor = colorData.hex;
            const eyeColor = colorData.eye;
            
            // â˜…ä¿®æ­£: ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆã®è¦‹ç›´ã—
            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³ã¯ãƒ¡ã‚¤ãƒ³ã¨åŒã˜ã€‚å½±ã¯å°‘ã—æš—ãå½©åº¦ã‚’è½ã¨ã™ã€‚ãƒã‚¤ãƒ©ã‚¤ãƒˆã¯å»ƒæ­¢ã€‚
            const shadowColor = adjustBrightness(mainColor, -25); // ã‚„ã‚ã‚‰ã‹ã„å½±

            ctx.clearRect(0, 0, 20, 20); 

            let localSeed = noteIdx + pitchVal + typeVal + rndVal;
            const rand = () => { localSeed = (localSeed * 9301 + 49297) % 233280; return localSeed / 233280; };

            const gridSize = 20;
            // ã‚°ãƒªãƒƒãƒ‰ã®å€¤: 0=ãªã—, 1=ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³(ãƒ¡ã‚¤ãƒ³ã¨åŒè‰²), 2=ãƒ¡ã‚¤ãƒ³, 4=ã‚„ã‚ã‚‰ã‹ã„å½±
            const grid = Array(gridSize).fill(0).map(() => Array(gridSize).fill(0));

            const centerX = 9.5;
            const centerY = 10.5; 
            
            // ãƒ•ã‚©ãƒ«ãƒ è¨ˆç®—ï¼ˆä¸Šç´°ä¸‹å¤ªã®å¤§ç¦ï¼‰
            let squash = 0.7 + (pitchVal / 255) * 0.3;
            const baseRadiusW = 8.0;
            const baseRadiusH = 8.0 * squash;

            // ãƒœãƒ‡ã‚£æç”»
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dx = x - centerX;
                    const dy = y - centerY;
                    let dynamicRadiusW = baseRadiusW * (1.0 + dy * 0.04);
                    if ((dx*dx)/(dynamicRadiusW*dynamicRadiusW) + (dy*dy)/(baseRadiusH*baseRadiusH) <= 0.95) {
                        grid[y][x] = 2; // ãƒ¡ã‚¤ãƒ³ã‚«ãƒ©ãƒ¼
                    }
                }
            }

            // ãƒ‘ãƒ¼ãƒ„(è€³ãƒ»è§’) - ãƒ¡ã‚¤ãƒ³ã¨å½±ã§å¡—ã‚Šåˆ†ã‘
            const partsType = rndVal % 4; 
            let bodyTopY = 0;
            for(let y=0; y<gridSize/2; y++) { if(grid[y][9] === 2) { bodyTopY = y; break; } }
            const earX = Math.floor(centerX - 2);
            const earBaseY = bodyTopY;

            if (earBaseY >= 1) {
                if (partsType === 0) { // ä¸¸è€³é¢¨
                    grid[earBaseY][earX]=2; grid[earBaseY][earX-1]=2;
                    grid[earBaseY-1][earX]=2; grid[earBaseY-1][earX-1]=2;
                    grid[earBaseY][earX-1]=4; // å†…å´ã‚’å½±ã«
                } else if (partsType === 1) { // ã¡ã‚‡ã“ã‚“è§’
                    grid[earBaseY-1][earX]=2; grid[earBaseY-2][earX]=2;
                    grid[earBaseY-1][earX]=4; // ä¸‹éƒ¨ã‚’å½±ã«
                } else if (partsType === 2) { // ãªãªã‚è€³
                    grid[earBaseY][earX-1]=2; grid[earBaseY-1][earX-1]=2; grid[earBaseY-1][earX-2]=2;
                    grid[earBaseY][earX-1]=4; // å†…å´ã‚’å½±ã«
                }
            }
            
            // è¶³ - ç«‹ä½“çš„ã«
            let bodyBottomY = gridSize-1;
            for(let y=gridSize-1; y>gridSize/2; y--) { if(grid[y][9] === 2) { bodyBottomY = y; break; } }
            const legX = Math.floor(centerX - 3);
            if (bodyBottomY < gridSize-1) {
                grid[bodyBottomY+1][legX] = 2; grid[bodyBottomY+2][legX] = 1; // æ¥åœ°ã‚’ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³(ãƒ¡ã‚¤ãƒ³åŒè‰²)ã«
                grid[bodyBottomY+1][legX-1] = 2; grid[bodyBottomY+2][legX-1] = 1;
            }

            // åè»¢ã‚³ãƒ”ãƒ¼
            for (let y = 0; y < gridSize; y++) {
                for (let x=0; x<10; x++) if (grid[y][x]!==0) grid[y][19-x]=grid[y][x];
            }

            // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³æ¤œå‡ºã¨ã‚„ã‚ã‚‰ã‹ã„å½±ã®é…ç½®
            const finalGrid = JSON.parse(JSON.stringify(grid));
            for (let y=0; y<gridSize; y++) {
                for (let x=0; x<gridSize; x++) {
                    // ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³æ¤œå‡º
                    if (grid[y][x] === 2 || grid[y][x] === 4) {
                        const neighbors = [[0,-1],[0,1],[-1,0],[1,0]];
                        let isEdge = false;
                        neighbors.forEach(([nx, ny]) => {
                            if (!grid[y+ny] || grid[y+ny][x+nx]===0) isEdge = true;
                        });
                        if(isEdge) finalGrid[y][x] = 1; 
                    }
                }
            }

            // â˜…ä¿®æ­£: ãƒã‚¤ãƒ©ã‚¤ãƒˆå‰Šé™¤ã€‚ã‚„ã‚ã‚‰ã‹ã„å½±ã®ã¿è£œè¶³çš„ã«è¿½åŠ ã€‚
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if(finalGrid[y][x] === 2) { 
                         // å³ä¸‹ã‚„ä¸‹éƒ¨ã«è£œè¶³çš„ãªã‚„ã‚ã‚‰ã‹ã„å½±ã‚’è¿½åŠ 
                         if(x > centerX + 2 && y > centerY + 2 && (x+y)%3 === 0) {
                             finalGrid[y][x] = 4;
                         }
                         else if(y > centerY + 5 && x%2 === 0) {
                             finalGrid[y][x] = 4;
                         }
                    }
                }
            }

            // æç”»å®Ÿè¡Œ
            for (let y=0; y<gridSize; y++) {
                for (let x=0; x<gridSize; x++) {
                    const val = finalGrid[y][x];
                    if (val !== 0) {
                        // â˜…ä¿®æ­£: ã‚¢ã‚¦ãƒˆãƒ©ã‚¤ãƒ³(1)ã¯ãƒ¡ã‚¤ãƒ³ã‚«ãƒ©ãƒ¼(2)ã¨åŒã˜è‰²ã§å¡—ã‚‹
                        if (val === 1 || val === 2) ctx.fillStyle = mainColor;
                        else if (val === 4) ctx.fillStyle = shadowColor;
                        ctx.fillRect(x, y, 1, 1);
                    }
                }
            }

            // ç›® (ä½ç½®ã¯ç¶­æŒ)
            const eyeY = Math.floor(centerY); 
            const eyeX_L = 6; 
            const eyeX_R = 12; 
            
            let eyePattern = typeVal % 3;
            // â˜…ä¿®æ­£: ç›®ã®æç”»é–¢æ•°ã«å½±è‰²ã‚’æ¸¡ã™
            drawSpecifiedEye(ctx, eyeX_L, eyeY, eyeColor, shadowColor, eyePattern);
            drawSpecifiedEye(ctx, eyeX_R, eyeY, eyeColor, shadowColor, eyePattern, true);
        }

        // â˜…ä¿®æ­£: æŒ‡å®šã•ã‚ŒãŸ3ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ç›®ã‚’ãƒ‰ãƒƒãƒˆå˜ä½ã§å®Ÿè£…
        function drawSpecifiedEye(ctx, x, y, color, shadow, pattern, isRight=false) {
            ctx.fillStyle = "#fff"; // ç™½ã¯ç›®ã ã‘
            
            if (pattern === 0) { 
                // ãƒ‘ã‚¿ãƒ¼ãƒ³1: ç™½2x2 + ä¸‹ã«ã‚«ãƒ©ãƒ¼2x2
                ctx.fillRect(x, y, 2, 2); // ç™½
                ctx.fillStyle = color; ctx.fillRect(x, y+2, 2, 2); // ã‚«ãƒ©ãƒ¼
            } 
            else if (pattern === 1) { 
                // ãƒ‘ã‚¿ãƒ¼ãƒ³2: ç™½2x2 + ä¸‹ã«å½±2x1 + ä¸‹ã«ã‚«ãƒ©ãƒ¼2x1
                ctx.fillRect(x, y, 2, 2); // ç™½
                ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); // å½±
                ctx.fillStyle = color;  ctx.fillRect(x, y+3, 2, 1); // ã‚«ãƒ©ãƒ¼
            } 
            else { 
                // ãƒ‘ã‚¿ãƒ¼ãƒ³3: ãƒ‘ã‚¿ãƒ¼ãƒ³2 + æ¨ªã«å½±1, ãã®ä¸Šã«ã‚«ãƒ©ãƒ¼1 (å¤–å´ã«è£…é£¾)
                ctx.fillRect(x, y, 2, 2); // ç™½
                ctx.fillStyle = shadow; ctx.fillRect(x, y+2, 2, 1); // å½±
                ctx.fillStyle = color;  ctx.fillRect(x, y+3, 2, 1); // ã‚«ãƒ©ãƒ¼
                
                // è£…é£¾ãƒ‰ãƒƒãƒˆ (å³ç›®ã¯å·¦å´ã«ã€å·¦ç›®ã¯å³å´ã«)
                const decoX = isRight ? x - 1 : x + 2;
                ctx.fillStyle = shadow; ctx.fillRect(decoX, y+2, 1, 1); // æ¨ªã®å½±
                ctx.fillStyle = color;  ctx.fillRect(decoX, y+1, 1, 1); // ãã®ä¸Šã®ã‚«ãƒ©ãƒ¼
            }
        }

        function updateStatusColor(noteIdx) {
            const d = SCALE_COLORS[noteIdx];
            mainStatus.innerText = d.name;
            mainStatus.style.color = d.hex;
            capsule.style.borderColor = d.hex;
            capsule.style.boxShadow = `0 0 20px ${d.hex}44`;
        }

        function setStepUI(step) {
            step1.className = "phase-step" + (step===1?" active":"") + (step>1?" locked":"");
            step2.className = "phase-step" + (step===2?" active":"") + (step>2?" locked":"");
            step3.className = "phase-step" + (step===3?" active":"") + (step>3?" locked":"");
        }

        function toHex(n) { return Math.floor(n||0).toString(16).padStart(2,'0').toUpperCase(); }
        // å½±è‰²ã‚’ä½œã‚‹ãŸã‚ã®é–¢æ•°ï¼ˆå½©åº¦ã‚‚å°‘ã—è½ã¨ã™ã‚ˆã†ã«èª¿æ•´ï¼‰
        function adjustBrightness(hex, p) {
            let r = parseInt(hex.slice(1,3), 16);
            let g = parseInt(hex.slice(3,5), 16);
            let b = parseInt(hex.slice(5,7), 16);
            
            // æ˜åº¦èª¿æ•´
            r = Math.max(0, Math.min(255, r + Math.round(2.55 * p)));
            g = Math.max(0, Math.min(255, g + Math.round(2.55 * p)));
            b = Math.max(0, Math.min(255, b + Math.round(2.55 * p)));

            // å½©åº¦ã‚’å°‘ã—è½ã¨ã™ï¼ˆã‚°ãƒ¬ãƒ¼ã«è¿‘ã¥ã‘ã‚‹ï¼‰
            if (p < 0) {
                const avg = (r + g + b) / 3;
                r = r + (avg - r) * 0.2;
                g = g + (avg - g) * 0.2;
                b = b + (avg - b) * 0.2;
            }

            return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
        }

        function copySeed() {
            seedInput.select();
            document.execCommand("copy");
            subStatus.innerText = "ã‚³ãƒ¼ãƒ‰ã‚’ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼";
        }

        function loadFromSeed() {
            const val = seedInput.value.trim();
            if(val.startsWith("BM-")) {
                const raw = val.replace(/[^0-9A-F]/g, '');
                drawMonster(parseInt(raw.substring(0,2),16), parseInt(raw.substring(2,4),16), parseInt(raw.substring(4,6),16), parseInt(raw.substring(6,8),16));
                updateStatusColor(parseInt(raw.substring(0,2),16));
                subStatus.innerText = "ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ã‚’å¾©å…ƒã—ã¾ã—ãŸï¼";
            } else {
                alert("æ­£ã—ã„ã‚³ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ (ä¾‹: BM-XXXX-XXXX)");
            }
        }
    </script>
</body>
</html>