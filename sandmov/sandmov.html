<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>デジタル砂時計</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            display: flex;
            flex-direction: column;
            /* ★バグ修正: 'align' を 'align-items' に修正し、中央揃えを確実にします */
            align-items: center; 
            background-color: #f4f4f4;
            color: #333;
        }
        h1 {
            font-weight: 300;
        }
        
        #canvas-container {
            display: inline-block;
            border: 1px solid #ccc;
            background-color: #000;
            padding: 0;
            margin: 0;
            line-height: 0;
        }
        canvas {
            width: 100%;
            max-width: 500px;
            display: block;
        }
        video {
            display: none; 
        }

        .controls {
            margin-top: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 500px;
            width: 100%;
        }
        .control-group {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }
        .control-group h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group button {
            padding: 8px 12px;
            margin: 4px;
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            cursor: pointer;
            border-radius: 4px;
        }
        .control-group button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        #main-controls button {
            font-size: 1.1em;
            padding: 12px 20px;
            min-width: 100px;
        }
        #duration-controls {
            display: flex;
            align-items: center;
        }
        #duration-controls input {
            width: 60px;
            font-size: 1em;
            padding: 8px;
            margin-right: 10px;
            text-align: center;
        }
    </style>
</head>
<body>

    <h1>デジタル砂時計</h1>

    <div id="main-controls">
        <button id="play-pause-btn">再生</button>
    </div>

    <div id="canvas-container">
        <canvas id="sand-canvas"></canvas>
    </div>

    <video 
        id="sand-video" 
        src="/movie/sandmovie.mp4" 
        playsinline
        crossorigin="anonymous"> 
    </video>

    <div class="controls">
        <div class="control-group" id="duration-controls">
            <input type="number" id="duration-input" value="10" min="1">
            <label for="duration-input">秒で完了</label>
        </div>
        <div class="control-group">
            <h3>色 (Color)</h3>
            <div id="color-buttons">
                <button data-color="gray" class="active">Gray</button>
                <button data-color="red">R</button>
                <button data-color="green">G</button>
                <button data-color="blue">B</button>
                <button data-color="cyan">C</button>
                <button data-color="magenta">M</button>
                <button data-color="yellow">Y</button>
            </div>
        </div>
        <div class="control-group">
            <h3>音 (Noise)</h3>
            <div id="sound-buttons">
                <button data-sound="off" class="active">Off</button>
                <button data-sound="white">White</button>
                <button data-sound="pink">Pink</button>
                <button data-sound="brown">Brown</button>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // ----- 1. 要素の取得 -----
            const video = document.getElementById('sand-video');
            const canvas = document.getElementById('sand-canvas');
            const ctx = canvas.getContext('2d');

            const playPauseBtn = document.getElementById('play-pause-btn');
            const durationInput = document.getElementById('duration-input');
            const colorButtons = document.getElementById('color-buttons');
            const soundButtons = document.getElementById('sound-buttons');
            
            const ORIGINAL_DURATION = 18.0;

            let animationFrameId = null;
            let targetColor = 'gray'; 

            // ----- 2. Web Audio API (変更なし) -----
            let audioCtx;
            let whiteNoiseNode, pinkNoiseNode, brownNoiseNode;
            let currentNoiseNode = null;
            const noiseVolume = 0.08;
            const FADE_DURATION = 0.5;

            function createNoiseGenerators() {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const bufferSize = 4096;
                whiteNoiseNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
                whiteNoiseNode.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
                };
                let lastOutBrown = 0.0;
                brownNoiseNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
                brownNoiseNode.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        output[i] = (lastOutBrown + (0.02 * white)) / 1.02;
                        lastOutBrown = output[i]; output[i] *= 3.5; 
                    }
                };
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                pinkNoiseNode = audioCtx.createScriptProcessor(bufferSize, 1, 1);
                pinkNoiseNode.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) {
                        const white = Math.random() * 2 - 1;
                        b0 = 0.99886 * b0 + white * 0.0555179; b1 = 0.99332 * b1 + white * 0.0750759;
                        b2 = 0.96900 * b2 + white * 0.1538520; b3 = 0.86650 * b3 + white * 0.3104856;
                        b4 = 0.55000 * b4 + white * 0.5329522; b5 = -0.7616 * b5 - white * 0.0168980;
                        const total = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                        b6 = white * 0.115926; output[i] = total / 7.0; 
                    }
                };
                [whiteNoiseNode, pinkNoiseNode, brownNoiseNode].forEach(node => {
                    const gainNode = audioCtx.createGain();
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime); 
                    node.connect(gainNode); gainNode.connect(audioCtx.destination);
                    node.gainNode = gainNode; 
                });
            }
            function initAudio() {
                if (!audioCtx) createNoiseGenerators();
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }
            function scheduleNoiseFade(gainNode, totalDuration) {
                const now = audioCtx.currentTime;
                gainNode.gain.cancelScheduledValues(now);
                gainNode.gain.setValueAtTime(0, now);
                if (totalDuration <= FADE_DURATION * 2) {
                    const peakTime = now + totalDuration / 2;
                    const peakVolume = (totalDuration / 2 / FADE_DURATION) * noiseVolume;
                    gainNode.gain.linearRampToValueAtTime(peakVolume, peakTime);
                    gainNode.gain.linearRampToValueAtTime(0, now + totalDuration);
                } else {
                    const fadeOutStartTime = now + totalDuration - FADE_DURATION;
                    gainNode.gain.linearRampToValueAtTime(noiseVolume, now + FADE_DURATION);
                    gainNode.gain.setValueAtTime(noiseVolume, fadeOutStartTime);
                    gainNode.gain.linearRampToValueAtTime(0, now + totalDuration);
                }
            }
            
            // ----- 3. Canvas描画とピクセル処理 (変更なし) -----
            video.addEventListener('loadedmetadata', () => {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            });
            
            function drawFrame() {
                if (video.paused || video.ended) return;
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                if (targetColor !== 'gray') {
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    const data = imageData.data; 

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i+1];
                        const b = data[i+2];

                        const isGray = Math.abs(r - g) < 20 && Math.abs(g - b) < 20;
                        const isTargetBrightness = r > 30 && r < 100;

                        if (isGray && isTargetBrightness) {
                            const brightness = (r + g + b) / 3;
                            const mappedL = 50 + (brightness * 1.5);

                            switch (targetColor) {
                                case 'red':
                                    data[i] = mappedL; data[i+1] = 0; data[i+2] = 0;
                                    break;
                                case 'green':
                                    data[i] = 0; data[i+1] = mappedL; data[i+2] = 0;
                                    break;
                                case 'blue':
                                    data[i] = 0; data[i+1] = 0; data[i+2] = mappedL;
                                    break;
                                case 'cyan':
                                    data[i] = 0; data[i+1] = mappedL; data[i+2] = mappedL;
                                    break;
                                case 'magenta':
                                    data[i] = mappedL; data[i+1] = 0; data[i+2] = mappedL;
                                    break;
                                case 'yellow':
                                    data[i] = mappedL; data[i+1] = mappedL; data[i+2] = 0;
                                    break;
                            }
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                }
                animationFrameId = requestAnimationFrame(drawFrame);
            }

            function startCanvasLoop() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = requestAnimationFrame(drawFrame);
            }
            function stopCanvasLoop() {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // ----- 4. 再生速度のロジック (変更なし) -----
            function setPlaybackSpeed() {
                if (video.currentTime > 0 && video.paused) {
                    video.currentTime = 0;
                    if (!animationFrameId) {
                         ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    }
                }
                const targetTime = parseFloat(durationInput.value);
                if (targetTime > 0) {
                    video.playbackRate = ORIGINAL_DURATION / targetTime;
                }
            }
            durationInput.addEventListener('change', setPlaybackSpeed);
            setPlaybackSpeed();

            // ----- 5. メイン再生/停止ロジック (変更なし) -----
            playPauseBtn.addEventListener('click', togglePlayPause);

            function togglePlayPause() {
                initAudio();
                if (video.paused) {
                    setPlaybackSpeed(); 
                    video.play();
                } else {
                    video.pause();
                }
            }

            video.addEventListener('play', () => {
                playPauseBtn.textContent = '停止';
                startCanvasLoop();
                if (currentNoiseNode) {
                    const targetTime = parseFloat(durationInput.value);
                    const originalPlaybackRate = ORIGINAL_DURATION / targetTime;
                    const videoCurrentTimeReal = video.currentTime / originalPlaybackRate;
                    const remainingTime = targetTime - videoCurrentTimeReal;
                    if (remainingTime > 0) {
                        scheduleNoiseFade(currentNoiseNode.gainNode, remainingTime);
                    }
                }
            });

            video.addEventListener('pause', () => {
                playPauseBtn.textContent = '再生';
                stopCanvasLoop();
                [whiteNoiseNode, pinkNoiseNode, brownNoiseNode].forEach(node => {
                    if(node) {
                        node.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                        node.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                    }
                });
            });

            video.addEventListener('ended', () => {
                playPauseBtn.textContent = '再生';
                stopCanvasLoop();
                video.currentTime = 0; 
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            });

            // ----- 6. 色変更ロジック (変更なし) -----
            colorButtons.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    targetColor = e.target.dataset.color;
                    
                    if (video.paused && !animationFrameId) {
                        drawFrame(); 
                        if (animationFrameId) cancelAnimationFrame(animationFrameId); 
                        animationFrameId = null;
                    }
                    updateActiveButton(colorButtons, e.target);
                }
            });

            // ----- 7. ノイズ変更ロジック (変更なし) -----
            soundButtons.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    initAudio();
                    const soundType = e.target.dataset.sound;
                    const oldNoiseNode = currentNoiseNode;
                    
                    if (soundType === 'white') currentNoiseNode = whiteNoiseNode;
                    else if (soundType === 'pink') currentNoiseNode = pinkNoiseNode;
                    else if (soundType === 'brown') currentNoiseNode = brownNoiseNode;
                    else currentNoiseNode = null;

                    if (oldNoiseNode) {
                        oldNoiseNode.gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                        oldNoiseNode.gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                    }
                    
                    if (currentNoiseNode && !video.paused) {
                        const targetTime = parseFloat(durationInput.value);
                        const originalPlaybackRate = ORIGINAL_DURATION / targetTime;
                        const videoCurrentTimeReal = video.currentTime / originalPlaybackRate;
                        const remainingTime = targetTime - videoCurrentTimeReal;
                        if (remainingTime > 0) {
                            scheduleNoiseFade(currentNoiseNode.gainNode, remainingTime);
                        }
                    }
                    updateActiveButton(soundButtons, e.target);
                }
            });

            function updateActiveButton(container, activeButton) {
                container.querySelectorAll('button').forEach(btn => {
                    btn.classList.remove('active');
                });
                activeButton.classList.add('active');
            }
        });
    </script>

</body>
</html>